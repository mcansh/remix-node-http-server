import type http from "node:http";
import type { AppLoadContext, ServerBuild } from "@remix-run/node";
import { createRequestHandler as createRemixRequestHandler } from "@remix-run/node";
import {
  createReadableStreamFromReadable,
  writeReadableStreamToWritable,
} from "@remix-run/node";

/**
 * A function that returns the value to use as `context` in route `loader` and
 * `action` functions.
 *
 * You can think of this as an escape hatch that allows you to pass
 * environment/platform-specific values through to your loader/action, such as
 * values that are generated by Express middleware like `req.session`.
 */
export interface GetLoadContextFunction {
  (req: http.IncomingMessage, res: http.ServerResponse): AppLoadContext;
}

export type RequestHandler = ReturnType<typeof createRequestHandler>;

/**
 * Returns a request handler for Express that serves the response using Remix.
 */
export function createRequestHandler({
  build,
  getLoadContext,
  mode = process.env.NODE_ENV,
}: {
  build: ServerBuild;
  getLoadContext?: GetLoadContextFunction;
  mode?: string;
}) {
  let handleRequest = createRemixRequestHandler(build, mode);

  return async (req: http.IncomingMessage, res: http.ServerResponse) => {
    let request = createRemixRequest(req, res);
    let loadContext = getLoadContext?.(req, res);
    let response = await handleRequest(request, loadContext);
    return sendRemixResponse(res, response);
  };
}

export function createRemixHeaders(
  requestHeaders: http.IncomingHttpHeaders,
): Headers {
  let headers = new Headers();

  for (let [key, values] of Object.entries(requestHeaders)) {
    if (values) {
      if (Array.isArray(values)) {
        for (let value of values) {
          headers.append(key, value);
        }
      } else {
        headers.set(key, values);
      }
    }
  }

  return headers;
}

export function getURL(req: http.IncomingMessage): URL {
  return new URL(`http://${req.headers.host}${req.url}`);
}

export function createRemixRequest(
  req: http.IncomingMessage,
  res: http.OutgoingMessage,
): Request {
  let url = getURL(req);

  // Abort action/loaders once we can no longer write a response
  let controller = new AbortController();
  res.on("close", () => controller.abort());

  let init: RequestInit = {
    method: req.method,
    headers: createRemixHeaders(req.headers),
    signal: controller.signal,
  };

  if (req.method !== "GET" && req.method !== "HEAD") {
    init.body = createReadableStreamFromReadable(req);
    (init as { duplex: "half" }).duplex = "half";
  }

  return new Request(url.href, init);
}

async function sendRemixResponse(
  res: http.ServerResponse,
  nodeResponse: Response,
) {
  res.statusCode = nodeResponse.status;
  res.statusMessage = nodeResponse.statusText;

  for (let [key, values] of nodeResponse.headers.entries()) {
    res.appendHeader(key, values);
  }

  if (nodeResponse.body) {
    await writeReadableStreamToWritable(nodeResponse.body, res);
  } else {
    res.end();
  }
}
